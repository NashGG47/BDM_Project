# Streamlit Dashboard: Transport Sentiment Analysis (ENGLISH VERSION)

import streamlit as st
import pandas as pd
from minio import Minio
from transformers import pipeline
import plotly.express as px
from io import BytesIO
import os

# --- CONFIGURATION ---
BUCKET = "exploitation-zone"
TRANSPORT_PARQUET = "storage/social_media/bluesky/transport/posts_transport.parquet"
OTHER_PARQUET = "storage/social_media/bluesky/other/posts_other.parquet"
LOCAL_TRANSPORT = "data/posts_transport.parquet"
LOCAL_OTHER = "data/posts_other.parquet"

# --- MinIO Connection ---
def download_from_minio(object_path, local_path):
    client = Minio("localhost:9000", access_key="admin", secret_key="admin123", secure=False)
    os.makedirs("data", exist_ok=True)
    client.fget_object(BUCKET, object_path, local_path)
    st.success(f"‚úÖ {object_path} downloaded from MinIO")

# --- Load Data ---
def load_data():
    download_from_minio(TRANSPORT_PARQUET, LOCAL_TRANSPORT)
    download_from_minio(OTHER_PARQUET, LOCAL_OTHER)
    df_transport = pd.read_parquet(LOCAL_TRANSPORT)
    df_other = pd.read_parquet(LOCAL_OTHER)
    return df_transport, df_other

# --- Load Sentiment Model ---
@st.cache_resource
def load_model():
    return pipeline("sentiment-analysis", model="distilbert-base-uncased-finetuned-sst-2-english")

def analyze_sentiment(df, model):
    df = df.copy()
    df["sentiment"] = df["text"].apply(lambda t: model(t)[0]["label"] if pd.notnull(t) else None)
    return df

# --- Streamlit UI ---
st.set_page_config(page_title="üöá Transport & Other Posts Dashboard", layout="wide")
st.title("üìä BlueSky Posts Dashboard: Transport vs Others")

with st.spinner("üîÑ Loading data..."):
    df_transport, df_other = load_data()
    
    # ‚ùå Remove specific unwanted post
    df_transport = df_transport[~(
        (df_transport["source"].str.contains("elpais.com", case=False, na=False)) &
        (df_transport["text"].str.contains("musk recula en su choque con trump", case=False, na=False))
    )]

# Initial metrics
total_posts = len(df_transport) + len(df_other)
st.success(f"üì¶ {total_posts} posts loaded ({len(df_transport)} transport-related, {len(df_other)} other)")

# Volume comparison
st.subheader("üî¢ Category Distribution")
volume = pd.DataFrame({
    "category": ["Transport", "Other"],
    "posts": [len(df_transport), len(df_other)]
})
fig_bar = px.bar(volume, x="category", y="posts", color="category", color_discrete_sequence=["#1f77b4", "#ff7f0e"])
st.plotly_chart(fig_bar, use_container_width=True)

# Most active accounts
st.subheader("üë• Most Active Accounts (All Categories)")
df_total = pd.concat([df_transport.assign(category="Transport"), df_other.assign(category="Other")])
top_accounts = df_total["source"].value_counts().head(10).reset_index()
top_accounts.columns = ["account", "posts"]
fig_top = px.bar(top_accounts, x="account", y="posts", color="posts", color_continuous_scale="Viridis")
st.plotly_chart(fig_top, use_container_width=True)

# Sentiment analysis ONLY for transport
st.subheader("üß† Sentiment Analysis (Transport Only)")
model = load_model()
df_transport_sent = analyze_sentiment(df_transport, model)

# Sentiment pie chart
sent_pie = df_transport_sent["sentiment"].value_counts().reset_index()
sent_pie.columns = ["sentiment", "count"]
fig_sentiment = px.pie(sent_pie, values="count", names="sentiment",
                       color_discrete_map={"POSITIVE": "#4CAF50", "NEGATIVE": "#F44336", "NEUTRAL": "#FFC107"})
st.plotly_chart(fig_sentiment, use_container_width=True)

# Stacked bar: sentiment by top accounts
st.subheader("üìä Sentiment by Account (Top 5 in Transport)")
top5 = df_transport_sent["source"].value_counts().head(5).index.tolist()
df_top = df_transport_sent[df_transport_sent["source"].isin(top5)]
df_grouped = df_top.groupby(["source", "sentiment"]).size().reset_index(name="count")
fig_stack = px.bar(df_grouped, x="source", y="count", color="sentiment", barmode="stack",
                   color_discrete_map={"POSITIVE": "#4CAF50", "NEGATIVE": "#F44336", "NEUTRAL": "#FFC107"})
st.plotly_chart(fig_stack, use_container_width=True)

# Featured posts cards
st.subheader("üßæ Example Transport Posts with Sentiment")
emojis = {"POSITIVE": "üòä", "NEGATIVE": "üò°", "NEUTRAL": "üòê"}
colors = {"POSITIVE": "#e8f5e9", "NEGATIVE": "#ffebee", "NEUTRAL": "#fff8e1"}
rows = df_transport_sent.head(12).to_dict(orient="records")
cols = st.columns(3)
for idx, row in enumerate(rows):
    with cols[idx % 3]:
        st.markdown(f"""
        <div style="background-color:{colors.get(row['sentiment'], '#f0f0f0')}; padding:16px; border-radius:10px; margin-bottom:20px">
            <h5 style="margin-bottom:5px;">{emojis.get(row['sentiment'], '')} {row['sentiment'].capitalize()}</h5>
            <p><strong>Account:</strong> {row['source']}</p>
            <hr style="margin-top:5px;margin-bottom:5px;">
            <p style="font-size:15px; white-space:pre-wrap; word-break:break-word;">{row['text']}</p>
        </div>
        """, unsafe_allow_html=True)

# Download CSV
# Keep only useful columns
export_cols = ["timestamp", "text", "source", "sentiment"]
export_df = df_transport_sent[export_cols].copy()

# Export as UTF-8 with BOM to fix accents in Excel
# csv = export_df.to_csv(index=False, encoding="utf-8-sig")
# st.download_button("üì• Download Clean Transport Posts", data=csv, file_name="transport_posts_sentiment.csv", mime="text/csv")

# Create Excel file in memory
output = BytesIO()
with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
    export_df.to_excel(writer, sheet_name='Transport Posts', index=False)
    
st.download_button(
    label="üì• Download Clean Transport Posts (Excel)",
    data=output.getvalue(),
    file_name="transport_posts_sentiment.xlsx",
    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
)